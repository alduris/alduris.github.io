<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Color Range Maker</title>
		<link rel="stylesheet" type="text/css" href="main.css">
		<style>
			input[type=number], .block select, .input, .select {
				width: 8ch;
			}
			.input, .select {
				border: 1px solid black;
				border-radius: 4px;
				padding: 3px;
				background-color: white;
			}
			#floater {
				border: 1px solid currentColor;
				border-radius: 4px;
				background-color: var(--gray1);
				position: absolute;
				display: none;
				padding: 4px;
				gap: 2em;
				grid-template-columns: auto auto auto;
				user-select: none;
			}
			#floater.active {
				display: inline-grid;
				box-sizing: border-box;
				max-width: calc(100vw - 8px);
				overflow-x: auto;
				white-space: nowrap;
			}
			#floater .block {
				cursor: pointer;
				margin-block: 0.25em;
			}
			
			.container {
				background-color: #e9e9e9;
				border-radius: 1000px;
				display: inline-block;
			}
			.container:not(:empty) {
				display: contents;
			}
			.container:empty {
				padding: 0.5em;
				cursor: pointer;
				border: 1px solid currentColor;
				position: relative;
				color: black;
			}
			.container:empty::before {
				content: "+";
				position: absolute;
				width: 0;
				height: 0;
				display: inline-flex;
				align-items: center;
				justify-content: center;
			}
			
			.block {
				color: black;
				border-radius: 1000px;
				padding: 2px 6px;
				border: 1px solid black;
				display: inline-flex;
				gap: 1ch;
				align-items: center;
				cursor: default;
			}
			.block[data-type='inp'] {
				background-color: white;
				padding: 2px 10px;
				cursor: text;
			}
			.block[data-type='var'] {
				background-color: #ff7f00;
			}
			.block[data-type='op'] {
				background-color: #7fff00;
			}
			.block[data-type='type'] {
				background-color: #007fff;
			}
			.block[data-type='func'] {
				background-color: #ff007f;
			}
			.block[data-type='cond'] {
				background-color: #ffbf00;
			}
			.block[data-type='bool'] {
				background-color: #00ff3f;
			}
			
			.block input[type='number'], .block select {
				background-color: white;
				color: black;
				border-color: black;
			}
			
			.del {
				background-color: red;
				color: white;
				cursor: pointer;
				border: 1px solid black;
				border-radius: 50%;
				padding: revert;
			}
			
			#floater[data-type='var']  p:not([data-type='var']),  #floater[data-type='var']  div:not(div:has(p:not([data-type='var']))),
			#floater[data-type='op']   p:not([data-type='op']),   #floater[data-type='op']   div:not(div:has(p:not([data-type='op']))),
			#floater[data-type='type'] p:not([data-type='type']), #floater[data-type='type'] div:not(div:has(p:not([data-type='type']))),
			#floater[data-type='func'] p:not([data-type='func']), #floater[data-type='func'] div:not(div:has(p:not([data-type='func']))),
			#floater[data-type='cond'] p:not([data-type='cond']), #floater[data-type='cond'] div:not(div:has(p:not([data-type='cond']))),
			#floater[data-type='bool'] p:not([data-type='bool']), #floater[data-type='bool'] div:not(div:has(p:not([data-type='bool']))),
			#floater[data-type='inp']  p:not([data-type='inp']),  #floater[data-type='inp']  div:not(div:has(p:not([data-type='inp']))) {
				display:none;
			}
			#floater[data-type] {
				grid-template-columns: auto;
				gap: 0;
			}
			
			#error {
				font-style: italic;
			}
			#error:empty {
				display: none;
			}
		</style>
	</head>
	<body>
		<h1>Color Range Maker</h1>
		<p>For making color range bits for the <a href="https://rainworldmods.miraheze.org/" target="_blank">Rain World Mods Wiki</a> or others. Click on <span class="container"></span> symbols to input a new block. Remember that numbers must be kept between 0 and 1.</p>
		<hr>
		<h3>Input</h3>
		<form id="generate">
			<p><label>Width: <input type="number" min="1" max="4096" value="500" id="width" required></label></p>
			<p><label>Height: <input type="number" min="1" max="4096" value="500" id="height" required></label></p>
			<p><label>Mode: <select id="mode">
				<option value="rect" selected>Rectangle</option>
				<option value="vert">Triangle (vertex)</option>
				<option value="edge">Triangle (edge)</option>
			</select></label></p>
			<p style="overflow-x: auto; white-space: nowrap;">Code: <span class="container" id="base"></span></p>
			<p><input type="submit" value="Generate"></p>
		</form>
		<h3>Output</h3>
		<p id="error"></p>
		<p><canvas></canvas></p>
		<form id="download">
			<p>
				<label>Name: <input type="text" id="name" value="palette" pattern="[\w\d\-]+" title="Alphanumeric characters, underscores, and hyphens only">.png</label>
				<input type="submit" value="Download Image">
				|
				<input type="submit" value="Copy to Clipboard">
				|
				<input type="submit" value="Open in New Tab">
			</p>
		</form>
		<div id="floater">
			<div>
				<p data-type="inp">
					Input:<br>
					<span class="block" data-type="inp" data-pick="inp"><span class="input">0.5</span></span><br>
				</p>
				<p data-type="var">
					Variables:<br>
					<span class="block" data-type="var" data-pick="var-x"><b>x</b></span><br>
					<span class="block" data-type="var" data-pick="var-y"><b>y</b></span><br>
					<span class="block" data-type="var" data-pick="var-z"><b>z</b></span>
				</p>
				<p data-type="op">
					Operations:<br>
					<span class="block" data-type="op" data-pick="op-plus" ><span class="container"></span> + <span class="container"></span></span><br>
					<span class="block" data-type="op" data-pick="op-minus"><span class="container"></span> - <span class="container"></span></span><br>
					<span class="block" data-type="op" data-pick="op-times"><span class="container"></span> * <span class="container"></span></span><br>
					<span class="block" data-type="op" data-pick="op-div"  ><span class="container"></span> / <span class="container"></span></span><br>
					<span class="block" data-type="op" data-pick="op-mod"  ><span class="container"></span> % <span class="container"></span></span><br>
					<span class="block" data-type="op" data-pick="op-pow"  ><span class="container"></span> ^ <span class="container"></span></span><br>
					
					<span class="block" data-type="op" data-pick="op-floor"><b>floor</b> <span class="container"></span></span><br>
					<span class="block" data-type="op" data-pick="op-ceil" ><b>ceil</b> <span class="container"></span></span><br>
					<span class="block" data-type="op" data-pick="op-round"><b>round</b> <span class="container"></span></span><br>
				</p>
			</div>
			<div>
				<p data-type="type">
					Color Types:<br>
					<span class="block" data-type="type" data-pick="type-rgb"><b>rgb</b> <span class="container"></span> <span class="container"></span> <span class="container"></span></span><br>
					<span class="block" data-type="type" data-pick="type-hsl"><b>hsl</b> <span class="container"></span> <span class="container"></span> <span class="container"></span></span><br>
					<span class="block" data-type="type" data-pick="type-rgb-inp"><b>rgb</b> <span class="input">0.5</span> <span class="input">0.5</span> <span class="input">0.5</span></span><br>
					<span class="block" data-type="type" data-pick="type-hsl-inp"><b>hsl</b> <span class="input">0.5</span> <span class="input">0.5</span> <span class="input">0.5</span></span><br>
					
					<span class="block" data-type="type" data-pick="type-torgb"><b>to rgb</b> <span class="container"></span></span><br>
					<span class="block" data-type="type" data-pick="type-tohsl"><b>to hsl</b> <span class="container"></span></span><br>
					
					<span class="block" data-type="type" data-pick="type-part"><b>get part</b> <select disabled><option>1</option><option>2</option><option>3</option></select> of <span class="container"></span></span><br>
				</p>
				<p data-type="func">
					Functions:<br>
					<span class="block" data-type="func" data-pick="func-clamp01"><b>clamp01</b> <span class="container"></span></span><br>
					
					<span class="block" data-type="func" data-pick="func-lerp"   ><b>lerp</b> a: <span class="container"></span> b: <span class="container"></span> t: <span class="container"></span></span><br>
					<span class="block" data-type="func" data-pick="func-invlerp"><b>invlerp</b> a: <span class="container"></span> b: <span class="container"></span> t: <span class="container"></span></span><br>
					<span class="block" data-type="func" data-pick="func-lerpmap"><b>lerpmap</b> val: <span class="container"></span> from a: <span class="container"></span> to a: <span class="container"></span> from b: <span class="container"></span> to b: <span class="container"></span></span><br>
					
					<span class="block" data-type="func" data-pick="func-clamprand"><b>clamped random var</b> base: <span class="container"></span> dev: <span class="container"></span> k: <span class="container"></span> axis: <span class="container"></span></span><br>
					<span class="block" data-type="func" data-pick="func-wraprand"><b>wrapped random var</b> base: <span class="container"></span> dev: <span class="container"></span> k: <span class="container"></span> axis: <span class="container"></span></span><br>
				</p>
			</div>
			<div>
				<p data-type="cond">
					Conditionals:<br>
					<span class="block" data-type="cond" data-pick="cond-ifelse"><b>if</b> <span class="container"></span> <b>then:</b> <span class="container"></span> <b>else:</b> <span class="container"></span></span>
				</p>
				<p data-type="bool">
					Logic:<br>
					<span class="block" data-type="bool" data-pick="bool-eq"><span class="container"></span> = <span class="container"></span></span><br>
					<span class="block" data-type="bool" data-pick="bool-gt"><span class="container"></span> &gt; <span class="container"></span></span><br>
					<span class="block" data-type="bool" data-pick="bool-lt"><span class="container"></span> &lt; <span class="container"></span></span><br>
					<span class="block" data-type="bool" data-pick="bool-ge"><span class="container"></span> &#8805; <span class="container"></span></span><br>
					<span class="block" data-type="bool" data-pick="bool-le"><span class="container"></span> &#8804; <span class="container"></span></span><br>
					
					<span class="block" data-type="bool" data-pick="bool-and"><span class="container"></span> <b>and</b> <span class="container"></span></span><br>
					<span class="block" data-type="bool" data-pick="bool-or"><span class="container"></span> <b>or</b> <span class="container"></span></span><br>
					<span class="block" data-type="bool" data-pick="bool-not"><b>not</b> <span class="container"></span></span><br>
				</p>
			</div>
		</div>
		<script>
			const canv = document.querySelector("canvas");
			const ctx = canv.getContext("2d", {willReadFrequently: true});
			const datarep = {type:"base", inner:null};
			var activeSlot = null;
			
			document.getElementById("floater").addEventListener("mouseleave", (e) => {
				activeSlot = null;
				document.getElementById("floater").classList.remove("active");
				document.getElementById("floater").removeAttribute("data-type");
			});
			
			function containerHandler(self, ref, set) {
				if (self.children.length == 0) {
					const floater = document.getElementById("floater");
					floater.classList.remove("active");
					floater.removeAttribute("data-type");
					const forceType = self.getAttribute("data-force");
					if (forceType != null) {
						floater.setAttribute("data-type", forceType);
					}
					floater.classList.add("active");
					const b = self.getBoundingClientRect();
					const l = window.innerWidth - floater.getBoundingClientRect().width - 4;
					floater.style.top = Math.round(b.top + b.height + 2) + "px";
					floater.style.left = Math.max(4, Math.min(l, Math.round(b.left))) + "px";
					
					activeSlot = [self, ref, set];
				}
			}
			document.getElementById("base").addEventListener("click", (e) => {
				e.preventDefault();
				e.stopPropagation();
				containerHandler(document.getElementById("base"), datarep, "inner");
			});
			document.body.addEventListener("click", (e) => {
				const floater = document.getElementById("floater");
				if (floater.classList.contains("active")) {
					const bounds = floater.getBoundingClientRect();
					if (e.clientX < bounds.left || e.clientX > bounds.right || e.clientY < bounds.top || e.clientY > bounds.bottom) {
						activeSlot = null;
						document.getElementById("floater").classList.remove("active");
						document.getElementById("floater").removeAttribute("data-type");
					}
				}
			});
			
			function makeContainer(ref, set) {
				const el = document.createElement("span");
				el.classList.add("container");
				el.addEventListener("click", (e) => {
					e.preventDefault();
					e.stopPropagation();
					containerHandler(el, ref, set);
				});
				return el;
			}
			
			function makeDelete(block) {
				let slot = activeSlot;
				const el = document.createElement("button");
				el.innerText = "\xd7";
				el.classList.add("del");
				el.addEventListener("click", (e) => {
					e.preventDefault();
					e.stopPropagation();
					block.remove();
					slot[1][slot[2]] = null;
				});
				return el;
			}
			
			for (const el of document.getElementById("floater").querySelectorAll(".block[data-type]")) {
				el.addEventListener("click", (e) => {
					if (activeSlot != null && activeSlot[0].children.length == 0) {
						let result = null, block = null;
						
						switch (el.getAttribute("data-pick")) {
							case "inp": {
								result = {value:0.5};
								let inp = document.createElement("input");
								inp.type = "number";
								inp.step = "any";
								inp.value = 0.5;
								inp.addEventListener("change", (ev) => {
									result.value = Number(inp.value);
								});
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "inp");
								//block.appendChild(document.createTextNode("input"));
								block.appendChild(inp);
								break;
							}
							case "var-x":
								result = {};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "var");
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("x"));
								break;
							case "var-y":
								result = {};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "var");
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("y"));
								break;
							case "var-z":
								result = {};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "var");
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("z"));
								break;
							case "op-plus":
								result = {a: null, b: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "op");
								block.appendChild(makeContainer(result, "a"));
								block.appendChild(document.createTextNode("+"));
								block.appendChild(makeContainer(result, "b"));
								break;
							case "op-minus":
								result = {a: null, b: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "op");
								block.appendChild(makeContainer(result, "a"));
								block.appendChild(document.createTextNode("-"));
								block.appendChild(makeContainer(result, "b"));
								break;
							case "op-times":
								result = {a: null, b: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "op");
								block.appendChild(makeContainer(result, "a"));
								block.appendChild(document.createTextNode("*"));
								block.appendChild(makeContainer(result, "b"));
								break;
							case "op-div":
								result = {a: null, b: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "op");
								block.appendChild(makeContainer(result, "a"));
								block.appendChild(document.createTextNode("/"));
								block.appendChild(makeContainer(result, "b"));
								break;
							case "op-mod":
								result = {a: null, b: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "op");
								block.appendChild(makeContainer(result, "a"));
								block.appendChild(document.createTextNode("%"));
								block.appendChild(makeContainer(result, "b"));
								break;
							case "op-pow":
								result = {a: null, b: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "op");
								block.appendChild(makeContainer(result, "a"));
								block.appendChild(document.createTextNode("^"));
								block.appendChild(makeContainer(result, "b"));
								break;
							case "op-floor":
								result = {a: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "op");
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("floor"));
								block.appendChild(makeContainer(result, "a"));
								break;
							case "op-ceil":
								result = {a: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "op");
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("ceil"));
								block.appendChild(makeContainer(result, "a"));
								break;
							case "op-round":
								result = {a: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "op");
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("round"));
								block.appendChild(makeContainer(result, "a"));
								break;
							case "type-rgb":
								result = {r: null, g: null, b: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "type");
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("rgb"));
								block.appendChild(makeContainer(result, "r"));
								block.appendChild(makeContainer(result, "g"));
								block.appendChild(makeContainer(result, "b"));
								break;
							case "type-hsl":
								result = {h: null, s: null, l: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "type");
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("hsl"));
								block.appendChild(makeContainer(result, "h"));
								block.appendChild(makeContainer(result, "s"));
								block.appendChild(makeContainer(result, "l"));
								break;
							case "type-rgb-inp": {
								result = {r: 0.5, g: 0.5, b: 0.5};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "type");
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("rgb"));
								
								let r = document.createElement("input");
								let g = document.createElement("input");
								let b = document.createElement("input");
								r.type = g.type = b.type = "number";
								r.step = g.step = b.step = "any";
								r.min = g.min = b.min = 0;
								r.max = g.max = b.max = 1;
								r.value = g.value = b.value = 0.5;
								r.addEventListener("change", (ev) => {
									result.r = Number(r.value);
								});
								g.addEventListener("change", (ev) => {
									result.g = Number(g.value);
								});
								b.addEventListener("change", (ev) => {
									result.b = Number(b.value);
								});
								
								block.appendChild(r);
								block.appendChild(g);
								block.appendChild(b);
								break;
							}
							case "type-hsl-inp": {
								result = {h: 0.5, s: 0.5, l: 0.5};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "type");
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("hsl"));
								
								let h = document.createElement("input");
								let s = document.createElement("input");
								let l = document.createElement("input");
								h.type = s.type = l.type = "number";
								h.step = s.step = l.step = "any";
								s.min = l.min = 0;
								s.max = l.max = 1;
								h.value = s.value = l.value = 0.5;
								h.addEventListener("change", (ev) => {
									result.h = Number(h.value);
								});
								s.addEventListener("change", (ev) => {
									result.s = Number(s.value);
								});
								l.addEventListener("change", (ev) => {
									result.l = Number(l.value);
								});
								
								block.appendChild(h);
								block.appendChild(s);
								block.appendChild(l);
								break;
							}
							case "type-torgb":
								result = {c: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "type");
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("to rgb"));
								block.appendChild(makeContainer(result, "c"));
								break;
							case "type-tohsl":
								result = {c: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "type");
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("to hsl"));
								block.appendChild(makeContainer(result, "c"));
								break;
							case "type-part": {
								result = {c: null, part: 1};
								
								let sel = document.createElement("select");
								for (let i = 1; i <= 3; i++) {
									let op = sel.appendChild(document.createElement("option"));
									op.value = i;
									op.innerText = i;
								}
								sel.addEventListener("change", (ev) => {
									if (sel.value >= 1 && sel.value <= 3) {
										result.part = Number(sel.value);
									} else {
										sel.selectedIndex = 0;
									}
								});
								sel.selectedIndex = 0;
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "type");
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("get part"));
								block.appendChild(sel);
								block.appendChild(document.createTextNode("of"));
								block.appendChild(makeContainer(result, "c"));
								break;
							}
							case "func-clamp01":
								result = {a: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "func");
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("clamp01"));
								block.appendChild(makeContainer(result, "a"));
								break;
							case "func-lerp":
								result = {a: null, b: null, t: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "func");
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("lerp"));
								block.appendChild(document.createTextNode("a:"));
								block.appendChild(makeContainer(result, "a"));
								block.appendChild(document.createTextNode("b:"));
								block.appendChild(makeContainer(result, "b"));
								block.appendChild(document.createTextNode("t:"));
								block.appendChild(makeContainer(result, "t"));
								break;
							case "func-invlerp":
								result = {a: null, b: null, t: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "func");
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("invlerp"));
								block.appendChild(document.createTextNode("a:"));
								block.appendChild(makeContainer(result, "a"));
								block.appendChild(document.createTextNode("b:"));
								block.appendChild(makeContainer(result, "b"));
								block.appendChild(document.createTextNode("t:"));
								block.appendChild(makeContainer(result, "t"));
								break;
							case "func-lerpmap":
								result = {val: null, fa: null, ta: null, fb: null, tb: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "func");
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("lerpmap"));
								block.appendChild(document.createTextNode("val:"));
								block.appendChild(makeContainer(result, "val"));
								block.appendChild(document.createTextNode("from a:"));
								block.appendChild(makeContainer(result, "fa"));
								block.appendChild(document.createTextNode("to a:"));
								block.appendChild(makeContainer(result, "ta"));
								block.appendChild(document.createTextNode("from b:"));
								block.appendChild(makeContainer(result, "fb"));
								block.appendChild(document.createTextNode("to b:"));
								block.appendChild(makeContainer(result, "tb"));
								break;
							case "func-clamprand":
								result = {b: null, d: null, k: null, v: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "func");
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("clamped random var"));
								block.appendChild(document.createTextNode("base:"));
								block.appendChild(makeContainer(result, "b"));
								block.appendChild(document.createTextNode("dev:"));
								block.appendChild(makeContainer(result, "d"));
								block.appendChild(document.createTextNode("k:"));
								block.appendChild(makeContainer(result, "k"));
								block.appendChild(document.createTextNode("var:"));
								block.appendChild(makeContainer(result, "v")).setAttribute("data-force", "var");
								break;
							case "func-wraprand":
								result = {b: null, d: null, k: null, v: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "func");
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("wrapped random var"));
								block.appendChild(document.createTextNode("base:"));
								block.appendChild(makeContainer(result, "b"));
								block.appendChild(document.createTextNode("dev:"));
								block.appendChild(makeContainer(result, "d"));
								block.appendChild(document.createTextNode("k:"));
								block.appendChild(makeContainer(result, "k"));
								block.appendChild(document.createTextNode("var:"));
								block.appendChild(makeContainer(result, "v")).setAttribute("data-force", "var");
								break;
							case "cond-ifelse":
								result = {cond: null, a: null, b: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "cond");
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("if"));
								block.appendChild(makeContainer(result, "cond")).setAttribute("data-force", "bool");
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("then:"));
								block.appendChild(makeContainer(result, "a"));
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("else:"));
								block.appendChild(makeContainer(result, "b"));
								break;
							case "bool-eq":
								result = {a: null, b: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "bool");
								block.appendChild(makeContainer(result, "a"));
								block.appendChild(document.createTextNode("="));
								block.appendChild(makeContainer(result, "b"));
								break;
							case "bool-gt":
								result = {a: null, b: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "bool");
								block.appendChild(makeContainer(result, "a"));
								block.appendChild(document.createTextNode(">"));
								block.appendChild(makeContainer(result, "b"));
								break;
							case "bool-lt":
								result = {a: null, b: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "bool");
								block.appendChild(makeContainer(result, "a"));
								block.appendChild(document.createTextNode("<"));
								block.appendChild(makeContainer(result, "b"));
								break;
							case "bool-ge":
								result = {a: null, b: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "bool");
								block.appendChild(makeContainer(result, "a"));
								block.appendChild(document.createTextNode("\u2265"));
								block.appendChild(makeContainer(result, "b"));
								break;
							case "bool-le":
								result = {a: null, b: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "bool");
								block.appendChild(makeContainer(result, "a"));
								block.appendChild(document.createTextNode("\u2264"));
								block.appendChild(makeContainer(result, "b"));
								break;
							case "bool-and":
								result = {a: null, b: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "bool");
								block.appendChild(makeContainer(result, "a")).setAttribute("data-force", "bool");
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("and"));
								block.appendChild(makeContainer(result, "b")).setAttribute("data-force", "bool");
								break;
							case "bool-or":
								result = {a: null, b: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "bool");
								block.appendChild(makeContainer(result, "a")).setAttribute("data-force", "bool");
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("or"));
								block.appendChild(makeContainer(result, "b")).setAttribute("data-force", "bool");
								break;
							case "bool-not":
								result = {a: null};
								
								block = document.createElement("span");
								block.classList.add("block");
								block.setAttribute("data-type", "bool");
								block.appendChild(document.createElement("b")).appendChild(document.createTextNode("not"));
								block.appendChild(makeContainer(result, "a")).setAttribute("data-force", "bool");
								break;
						}
						
						if (result != null && block != null) {
							result.type = el.getAttribute("data-pick");
							activeSlot[0].appendChild(block);
							activeSlot[1][activeSlot[2]] = result;
							block.insertAdjacentElement("afterbegin", makeDelete(block));
						}
					}
					
					activeSlot = null;
					document.getElementById("floater").classList.remove("active");
					document.getElementById("floater").removeAttribute("data-type");
				});
			}
			
			function lerp(x, y, a) {
				a = clamp(a,0,1);
				return x * (1-a) + y*a;
			}
			function lerpcol(x, y, a) {
				a = clamp(a,0,1);
				return [lerp(x[0], y[0], a), lerp(x[1], y[1], a), lerp(x[2], y[2], a)];
			}
			function invlerp(x, y, a) {
				if (x == y) return 0;
				return clamp((a-x) / (y-x),0,1);
			}
			function clamp(x, a, b) {
				if (isNaN(x)) return a;
				return x < a ? a : (x > b ? b : x);
			}
			function clampcol(x, a, b) {
				return [clamp(x[0], a, b), clamp(x[1], a, b), clamp(x[2], a, b)];
			}
			
			function randdev(k, l) {
				let m = (l < 0.5 ? -1 : 1);
				l = (l < 0.5 ? 0.5 - l : l - 0.5);
				
				let s = l * 2 - 1;
				if (s < 0) {
					s = Math.abs(1 + s);
					s = k * s / (k - s + 1) * 0.5;
				} else {
					s = -1 - s;
					s = 0.5 + k * s / (k - s + 1) * 0.5;
				}
				
				return s * 2 * m;
			}
			function clampedrandvar(b, d, k, l) {
				let v = b + d * randdev(k, l);
				if (v > 1) v = 1;
				else if (v < 0) v = 0;
				return v;
			}
			function wrappedrandvar(b, d, k, l) {
				let v = b + d * randdev(k, l) + 1;
				return v - Math.floor(v);
			}
			
			function hsl2rgb([h, sl, l]) {
				// from in-game code so as to simulate its buggy implementation
				let r = l;
				let g = l;
				let b = l;
				let v = ((l <= 0.5) ? (l * (1 + sl)) : (l + sl - l * sl));
				if (v > 0)
				{
					let i = l + l - v;
					let sv = (v - i) / v;
					h *= 6;
					let sextant = Math.floor(h);
					let fract = h - sextant;
					let vsf = v * sv * fract;
					let mid1 = i + vsf;
					let mid2 = v - vsf;
					switch (sextant) {
						case 0:
							r = v;
							g = mid1;
							b = i;
							break;
						case 1:
							r = mid2;
							g = v;
							b = i;
							break;
						case 2:
							r = i;
							g = v;
							b = mid1;
							break;
						case 3:
							r = i;
							g = mid2;
							b = v;
							break;
						case 4:
							r = mid1;
							g = i;
							b = v;
							break;
						case 5:
							r = v;
							g = i;
							b = mid2;
							break;
					}
				}
				return [r, g, b];
			}
			function rgb2hsl([r,g,b]) {
				// https://stackoverflow.com/a/54071699
				let v=Math.max(r,g,b), c=v-Math.min(r,g,b), f=(1-Math.abs(v+v-c-1)); 
				let h= c && ((v==r) ? (g-b)/c : ((v==g) ? 2+(b-r)/c : 4+(r-g)/c)); 
				return [(h<0?h+6:h)/6, f ? c/f : 0, (v+v-c)/2];
			}
			function rgb([r,g,b]) {
				return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
			}
			function tohex([r,g,b]) {
				r = clamp(Math.round(r),0,255).toString(16).padStart(2, "0");
				g = clamp(Math.round(g),0,255).toString(16).padStart(2, "0");
				b = clamp(Math.round(b),0,255).toString(16).padStart(2, "0");
				return "#" + r + g + b;
			}
			
			const FALSE = {type:"bool", value:false};
			const TRUE = {type:"bool", value:true};
			function process(item, x, y, z) {
				if (item == null) {
					return {type:"none"};
				}
				
				switch (item.type) {
					case "base":
						return process(item.inner, x, y, z);
					case "inp":
						if (isNaN(item.value)) throw "Input was not a number!";
						if (!isFinite(item.value)) throw "Input was not finite!";
						return {type:"number", value:item.value};
					case "var-x":
						return {type:"number", value:x};
					case "var-y":
						return {type:"number", value:y};
					case "var-z":
						return {type:"number", value:z};
					case "op-plus": {
						let a = process(item.a, x, y, z);
						let b = process(item.b, x, y, z);
						if (a.type != b.type) {
							throw "Type mismatch in addition!";
						} else if (a.type == "number") {
							return {type:"number", value:a.value+b.value};
						} else if (a.type == "rgb" || a.type == "hsl") {
							return {type:a.type, value:[a.value[0]+b.value[0], a.value[1]+b.value[1], a.value[2]+b.value[2]]};
						} else {
							throw "Invalid type passed into addition!";
						}
					}
					case "op-minus": {
						let a = process(item.a, x, y, z);
						let b = process(item.b, x, y, z);
						if (a.type != b.type) {
							throw "Type mismatch in subtraction!";
						} else if (a.type == "number") {
							return {type:"number", value:a.value-b.value};
						} else if (a.type == "rgb" || a.type == "hsl") {
							return {type:a.type, value:[a.value[0]-b.value[0], a.value[1]-b.value[1], a.value[2]-b.value[2]]};
						} else {
							throw "Invalid type passed into subtraction!";
						}
					}
					case "op-times": {
						let a = process(item.a, x, y, z);
						let b = process(item.b, x, y, z);
						if (a.type == "number" && (b.type == "rgb" || b.type == "hsl")) {
							return {type:b.type, value:[b.value[0] * a.value, b.value[1] * a.value, b.value[2] * a.value]};
						} else if (b.type == "number" && (a.type == "rgb" || a.type == "hsl")) {
							return {type:a.type, value:[a.value[0] * b.value, a.value[1] * b.value, a.value[2] * b.value]};
						} else if (a.type != b.type) {
							throw "Invalid types passed into multiplication!";
						} else if (a.type == "number") {
							return {type:"number", value:a.value*b.value};
						} else if (a.type == "rgb" || a.type == "hsl") {
							return {type:a.type, value:[a.value[0]*b.value[0], a.value[1]*b.value[1], a.value[2]*b.value[2]]};
						} else {
							throw "Invalid types passed into multiplication!";
						}
					}
					case "op-div": {
						let a = process(item.a, x, y, z);
						let b = process(item.b, x, y, z);
						if (a.type == "number" && (b.type == "rgb" || b.type == "hsl")) {
							return {type:b.type, value:[b.value[0] / a.value, b.value[1] / a.value, b.value[2] / a.value]};
						} else if (b.type == "number" && (a.type == "rgb" || a.type == "hsl")) {
							return {type:a.type, value:[a.value[0] / b.value, a.value[1] / b.value, a.value[2] / b.value]};
						} else if (a.type != b.type) {
							throw "Invalid types passed into division!";
						} else if (a.type == "number") {
							return {type:"number", value:a.value/b.value};
						} else if (a.type == "rgb" || a.type == "hsl") {
							return {type:a.type, value:[a.value[0]/b.value[0], a.value[1]/b.value[1], a.value[2]/b.value[2]]};
						} else {
							throw "Invalid types passed into division!";
						}
					}
					case "op-mod": {
						let a = process(item.a, x, y, z);
						let b = process(item.b, x, y, z);
						
						if (a.type == "number" && b.type == "number") {
							return {type:"number", value:a.value%b.value};
						}
						throw "Modulo only operates on numbers!";
					}
					case "op-pow": {
						let a = process(item.a, x, y, z);
						let b = process(item.b, x, y, z);
						if (a.type == "number" && b.type == "number") {
							return {type:"number", value: Math.pow(a.value, b.value)};
						}
						throw "Pow only operates on numbers!";
					}
					case "op-floor": {
						let a = process(item.a, x, y, z);
						if (a.type == "number") {
							return {type:"number", value: Math.floor(a.value)};
						}
						throw "Floor only operates on numbers!";
					}
					case "op-ceil": {
						let a = process(item.a, x, y, z);
						if (a.type == "number") {
							return {type:"number", value: Math.ceil(a.value)};
						}
						throw "Ceiling only operates on numbers!";
					}
					case "op-round": {
						let a = process(item.a, x, y, z);
						if (a.type == "number") {
							return {type:"number", value: Math.round(a.value)};
						}
						throw "Round only operates on numbers!";
					}
					case "type-rgb": {
						let r = process(item.r, x, y, z);
						let g = process(item.g, x, y, z);
						let b = process(item.b, x, y, z);
						if (r.type == "number" && g.type == "number" && b.type == "number") {
							return {type:"rgb", value:clampcol([r.value, g.value, b.value], 0, 1)};
						}
						throw "rgb can only operate with numbers!";
					}
					case "type-hsl": {
						// shhh I was too lazy to change the variable names
						let r = process(item.h, x, y, z);
						let g = process(item.s, x, y, z);
						let b = process(item.l, x, y, z);
						if (r.type == "number" && g.type == "number" && b.type == "number") {
							return {type:"hsl", value:clampcol([r.value, g.value, b.value], 0, 1)};
						}
						throw "hsl can only operate with numbers!";
					}
					case "type-rgb-inp": {
						let r = item.r;
						let g = item.g;
						let b = item.b;
						if (isNaN(r) || isNaN(g) || isNaN(b)) throw "Input was not a number!";
						if (!isFinite(r) || !isFinite(g) || !isFinite(b)) throw "Input was not finite!";
						return {type:"rgb", value:clampcol([r, g, b], 0, 1)};
					}
					case "type-hsl-inp": {
						let h = item.h;
						let s = item.s;
						let l = item.l;
						if (isNaN(h) || isNaN(s) || isNaN(l)) throw "Input was not a number!";
						if (!isFinite(h) || !isFinite(s) || !isFinite(l)) throw "Input was not finite!";
						return {type:"hsl", value:clampcol([h, s, l], 0, 1)};
					}
					case "type-torgb": {
						let c = process(item.c, x, y, z);
						if (c.type == "rgb") return c;
						if (c.type == "hsl") {
							return {type:"rgb", value:hsl2rgb(c.value)};
						}
						if (c.type == "number") {
							return {type:"rgb", value:[c.value,c.value,c.value]};
						}
						throw "Invalid type passed into RGB converter!";
					}
					case "type-tohsl": {
						let c = process(item.c, x, y, z);
						if (c.type == "hsl") return c;
						if (c.type == "rgb") {
							return {type:"hsl", value:rgb2hsl(c.value)};
						}
						if (c.type == "number") {
							return {type:"hsl", value:[c.value,1,0.5]};
						}
						throw "Invalid type passed into HSL converter!";
					}
					case "type-part": {
						let c = process(item.c, x, y, z);
						if (c.type == "hsl" || c.type == "rgb") return {type:"number", value:c.value[item.part - 1]};
						throw "Cannot extract part from non-color!";
					}
					case "func-clamp01": {
						let a = process(item.a, x, y, z);
						if (a.type == "number") {
							return {type:"number", value: clamp(a.value, 0, 1)};
						} else if (a.type == "rgb") {
							return {type:"rgb", value: [clamp(a.value[0], 0, 1), clamp(a.value[1], 0, 1), clamp(a.value[2], 0, 1)]};
						} else if (a.type == "hsl") {
							return {type:"hsl", value: [a.value[0] - Math.floor(a.value[0]), clamp(a.value[1], 0, 1), clamp(a.value[2], 0, 1)]};
						}
						throw "Invalid type passed into clamp01!";
					}
					case "func-lerp": {
						let a = process(item.a, x, y, z);
						let b = process(item.b, x, y, z);
						let t = process(item.t, x, y, z);
						if (t.type != "number") throw "t must be a number in lerp!";
						if (a.type != b.type) throw "a and b types must match in lerp!";
						if (a.type == "number") return {type:"number", value:lerp(a.value, b.value, t.value)};
						else if (a.type == "rgb") {
							return {type:a.type, value:lerpcol(a.value, b.value, t.value)};
						} else if (a.type == "hsl") {
							let val = {type:a.type, value:lerpcol(a.value, b.value, t.value)};
							val.value[0] = clamp(val.value[0] - Math.floor(val.value[0]), 0, 1);
							return val;
						}
						else throw "Invalid type passed into lerp!";
					}
					case "func-invlerp": {
						let a = process(item.a, x, y, z);
						let b = process(item.b, x, y, z);
						let t = process(item.t, x, y, z);
						if (t.type != "number" || a.type != b.type || a.type != "number") throw "Invlerp only operates on numbers!";
						return {type:"number", value:invlerp(a.value, b.value, t.value)};
					}
					case "func-lerpmap": {
						let v = process(item.val, x, y, z);
						let fa = process(item.fa, x, y, z);
						let ta = process(item.ta, x, y, z);
						let fb = process(item.fb, x, y, z);
						let tb = process(item.tb, x, y, z);
						if (v.type != "number" || fa.type != "number" || ta.type != "number" || fb.type != "number" || tb.type != "number") throw "Lerpmap only operates on numbers!";
						return {type:"number", value:lerp(fb.value, tb.value, invlerp(fa.value, ta.value, v.value))};
					}
					case "func-clamprand": {
						let b = process(item.b, x, y, z);
						let d = process(item.d, x, y, z);
						let k = process(item.k, x, y, z);
						let v = process(item.v, x, y, z);
						if (b.type != "number" || d.type != "number" || k.type != "number" || v.type != "number") throw "Clamped random variation only operates on numbers!";
						return {type:"number", value:clampedrandvar(b.value,d.value,k.value,v.value)};
					}
					case "func-wraprand": {
						let b = process(item.b, x, y, z);
						let d = process(item.d, x, y, z);
						let k = process(item.k, x, y, z);
						let v = process(item.v, x, y, z);
						if (b.type != "number" || d.type != "number" || k.type != "number" || v.type != "number") throw "Wrapped random variation only operates on numbers!";
						return {type:"number", value:wrappedrandvar(b.value,d.value,k.value,v.value)};
					}
					case "cond-ifelse": {
						let cond = process(item.cond, x, y, z);
						let a = process(item.a, x, y, z);
						let b = process(item.b, x, y, z);
						if (cond.type != "bool") throw "Condition must be boolean!";
						return cond.value ? a : b;
					}
					case "bool-eq": {
						let a = process(item.a, x, y, z);
						let b = process(item.b, x, y, z);
						if (a.type != b.type) return FALSE;
						else if (a.type == "number" || a.type == "bool") return a.value == b.value ? TRUE : FALSE;
						else if (a.type == "rgb" || a.type == "hsl") return (a.value[0] == b.value[0] && a.value[1] == b.value[1] && a.value[2] == b.value[2]) ? TRUE : FALSE;
						else throw "Invalid type passed into equals!";
					}
					case "bool-gt": {
						let a = process(item.a, x, y, z);
						let b = process(item.b, x, y, z);
						if (a.type != b.type) throw "Mismatched types in greater-than!";
						else if (a.type == "number" || a.type == "bool") return a.value > b.value ? TRUE : FALSE;
						else throw "Greater-than only operates on numbers!";
					}
					case "bool-lt": {
						let a = process(item.a, x, y, z);
						let b = process(item.b, x, y, z);
						if (a.type != b.type) throw "Mismatched types in less-than!";
						else if (a.type == "number" || a.type == "bool") return a.value < b.value ? TRUE : FALSE;
						else throw "Less-than only operates on numbers!";
					}
					case "bool-ge": {
						let a = process(item.a, x, y, z);
						let b = process(item.b, x, y, z);
						if (a.type != b.type) throw "Mismatched types in greater-than-or-equal-to!";
						else if (a.type == "number" || a.type == "bool") return a.value >= b.value ? TRUE : FALSE;
						else throw "Greater-than-or-equal-to only operates on numbers!";
					}
					case "bool-le": {
						let a = process(item.a, x, y, z);
						let b = process(item.b, x, y, z);
						if (a.type != b.type) throw "Mismatched types in less-than-or-equal-to!";
						else if (a.type == "number" || a.type == "bool") return a.value <= b.value ? TRUE : FALSE;
						else throw "Less-than-or-equal-to only operates on numbers!";
					}
					case "bool-and": {
						let a = process(item.a, x, y, z);
						let b = process(item.b, x, y, z);
						if (a.type != b.type || a.type != "bool") throw "Logical AND only operates on booleans!";
						return a.value && b.value ? TRUE : FALSE;
					}
					case "bool-or": {
						let a = process(item.a, x, y, z);
						let b = process(item.b, x, y, z);
						if (a.type != b.type || a.type != "bool") throw "Logical OR only operates on booleans!";
						return a.value || b.value ? TRUE : FALSE;
					}
					case "bool-not": {
						let a = process(item.a, x, y, z);
						if (a.type != "bool") throw "Logical NOT only operates on booleans!";
						return a.value ? FALSE : TRUE;
					}
				}
			}
			
			function getColor(item) {
				if (item.type == "number" || item.type == "bool") {
					return tohex([item.value * 255, item.value * 255, item.value * 255]);
				} else if (item.type == "hsl") {
					return tohex(rgb(hsl2rgb(item.value)));
				} else if (item.type == "rgb") {
					return tohex(rgb(item.value));
				} else if (item.type == "none") {
					throw "No final value returned!";
				}
				throw "Invalid result type \"" + item.type + "\"!"
			}

			function dist(x, y) {
				return Math.sqrt(x**2 + y**2);
			}
			function angle(x1, y1, x2, y2, x3, y3) {
				let a1 = x1-x2, b1 = x3-x2, a2 = y1-y2, b2 = y3-y2;
				return Math.acos((a1*b1 + a2*b2) / (dist(a1, a2) * dist(b1, b2)));
			}

			document.getElementById("generate").addEventListener("submit", (e) => {
				e.preventDefault();
				document.getElementById("error").innerHTML = "";
				
				try {
					const mode = document.getElementById("mode").value;
					const w = (canv.width = Number(document.getElementById("width").value)) - 1;
					const h = (canv.height = Number(document.getElementById("height").value)) - 1;
					const m = Math.abs(h * w + (w/2) * h - h * (w/2)) / Math.sqrt(h ** 2 + (w/2) ** 2);
					
					for (let x = 0; x < w; x++) {
						for (let y = 0; y < h; y++) {
							switch (mode) {
								case "rect": {
									ctx.fillStyle = getColor(process(datarep, x/w, y/h, 0));
									ctx.fillRect(x, y, 1, 1);
									break;
								}
								case "vert": {
									const a = -((h * x - (w/2) * y - h * (w/2)) / Math.sqrt(h ** 2 + (w/2) ** 2)) / m;
									const b = 1 - y / h;
									const c = ((h * x + (w/2) * y - h * (w/2)) / Math.sqrt(h ** 2 + (w/2) ** 2)) / m;
									if (a < 0 || b < 0 || c < 0 || a > 1 || b > 1 || c > 1) ctx.fillStyle = "#00000000";
									else ctx.fillStyle = getColor(process(datarep, a, b, c));
									ctx.fillRect(x, y, 1, 1);
									break;
								}
								case "edge": {
									const a = -((h * x - (w/2) * y - h * (w/2)) / Math.sqrt(h ** 2 + (w/2) ** 2)) / m;
									const b = 1 - y / h;
									const c = ((h * x + (w/2) * y - h * (w/2)) / Math.sqrt(h ** 2 + (w/2) ** 2)) / m;
									if (a < 0 || b < 0 || c < 0 || a > 1 || b > 1 || c > 1) ctx.fillStyle = "#00000000";
									else {
										const d = 1 - angle(0, h, w, h, x, y) / angle(0, h, w, h, w/2, 0);
										const e = angle(0, h, w/2, 0, x, y) / angle(0, h, w/2, 0, w, h);
										const f = angle(w, h, 0, h, x, y) / angle(w, h, 0, h, w/2, 0);
										ctx.fillStyle = getColor(process(datarep, d, e, f));
									}
									ctx.fillRect(x, y, 1, 1);
									break;
								}
							}
						}
					}
				} catch (e) {
					document.getElementById("error").innerText = e;
					canv.width = 0;
					canv.height = 0;
					throw e;
				}
			});

			document.getElementById("download").addEventListener("submit", (e) => {
				e.preventDefault();
				const val = e.submitter.value;
				if (val == "Download Image") {
					const a = document.createElement("a");
					const nm = document.getElementById("name");
					a.download = nm.checkValidity() ? nm.value + ".png" : "download.png";
					a.href = canv.toDataURL();
					a.click();
				} else if (val == "Copy to Clipboard") {
					canv.toBlob(function(blob) { 
						const item = new ClipboardItem({"image/png": blob});
						navigator.clipboard.write([item]); 
					});
				} else {
					const tab = window.open("", "_blank");
					tab.document.head.appendChild(document.createElement("style")).innerText = "img {image-rendering: pixelated;}";
					tab.document.body.appendChild(document.createElement("img")).src = canv.toDataURL();
					tab.focus();
				}
				return false;
			});
		</script>
	</body>
</html>
